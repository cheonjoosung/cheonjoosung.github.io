---
title: CS/컴퓨터공학 메모리 관리 기초 – 페이징(Paging) vs 세그멘테이션(Segmentation) 
tags: [CS]
style: fill
color: dark
description: CS/컴퓨터공학 메모리 관리 기초 – 페이징(Paging) vs 세그멘테이션(Segmentation)
---

## ✨ 개요

프로세스의 **가상 주소 공간**을 물리 메모리와 어떻게 매핑할까?  
운영체제(OS)는 크게 **페이징**과 **세그멘테이션**이라는 두 가지 고전 기법(또는 둘의 조합)으로 이 문제를 해결합니다.


---

## 1. 요약

- **페이징**: 가상/물리 메모리를 **고정 크기 블록**(페이지/프레임)으로 나눠 매핑
  + 장점: **외부 단편화 없음**, 간단한 교체/스왑, 보호·공유 쉬움
  + 단점: 마지막 페이지 **내부 단편화**, 페이지 테이블 비용, TLB 미스 시 오버헤드
- **세그멘테이션**: 코드/데이터/스택 등 **의미 단위(가변 크기)** 세그먼트로 관리
  + 장점: **논리적 구조 반영**, 세밀한 보호/공유, 내부 단편화 작음
  + 단점: **외부 단편화 발생**, 세그먼트 확장/압축 비용

현대 범용 OS는 **페이징(다단계/대페이지/TLB)**를 표준으로 쓰고,  
세그멘테이션은 **논리·권한 경계**에 국한되거나 거의 사용하지 않습니다(예: x86-64는 FS/GS 일부를 제외하고 세그먼트 대부분 비활성).


---

## 2 기본 개념

### 2.1 페이징(Paging)
- 가상 주소 = [페이지 번호 | 페이지 오프셋]
- 물리 주소 = [프레임 시작 주소] + 오프셋
- 페이지 크기(예: 4KB, 16KB, 64KB…)는 **고정**.

```text
아스키 다이어그램:
가상메모리 페이지테이블 물리메모리
[ P0 | off ] ---> [P0 -> F7] ----------> [ ... F7 .... ]
[ P1 | off ] ---> [P1 -> F2] ----------> [ ... F2 .... ]
```

### 2.2 세그멘테이션(Segmentation)
- 가상 주소 = [세그먼트 번호 | 세그먼트 내 오프셋]
- 세그먼트는 **가변 크기**이며, 용도별로 분할(코드/데이터/힙/스택 등).

```text
세그먼트 테이블
S0: base=B0, limit=L0, 권한=R-X
S1: base=B1, limit=L1, 권한=RW-
...
물리 주소 = base(S) + offset (단, offset < limit)
```

---

## 3 단편화( Fragmentation )

| 구분 | 내부 단편화 | 외부 단편화 |
|---|---|---|
| 정의 | 고정 블록에 데이터가 덜 차서 **블록 내부**가 남는 낭비 | 가변 블록을 할당/해제하다 **사이사이**에 잘게 남는 낭비 |
| 페이징 | **있을 수 있음** (마지막 페이지) | **없음** |
| 세그멘테이션 | **작음/없음** | **있음** (주요 단점) |

---

## 4. 주소 변환과 성능

### 4.1 TLB(Translation Lookaside Buffer)
- 최근에 변환한 **가상→물리** 매핑을 캐싱하는 **하드웨어 캐시**.
- **TLB 히트**: 빠른 변환, **TLB 미스**: 페이지 테이블을 다시 탐색 → 지연 증가.

### 4.2 페이지 테이블 최적화
- **다단계 페이지 테이블**: 희소한 주소 공간에 유리(필요한 부분만 테이블 할당).
- **Huge Pages/대페이지**(예: 2MB/1GB): 항목 수 감소 → **TLB 효율↑**, 단편화/메모리 낭비 트레이드오프.

---

## 5. 보호(Protection)와 공유(Sharing)

- **페이징**: 페이지 단위로 읽기/쓰기/실행 권한, **Copy-on-Write(CoW)**, 라이브러리 **코드 페이지 공유** 쉬움.
- **세그멘테이션**: 세그먼트 단위로 권한/크기/경계. 논리 구조와 보안 경계가 잘 맞음(이론적 장점).

현대 OS는 보호·공유 대부분을 **페이지 권한**으로 해결합니다.

---

## 6. 페이지 폴트와 스와핑

- **Demand Paging**: 접근 시점에 필요한 페이지를 **디스크→메모리**로 가져오기.
- **Page Fault**: 페이지가 없을 때 발생하는 트랩 → OS가 적절한 프레임에 적재.
- 메모리가 부족하면 **교체 알고리즘**(LRU 근사 등)으로 희생 페이지를 디스크에 쓰고 프레임 확보.

---

## 7. 페이징 vs 세그멘테이션 비교표

| 항목 | 페이징 | 세그멘테이션 |
|---|---|---|
| 단위 | 고정 크기 페이지 | 가변 크기 세그먼트 |
| 단편화 | **내부 O / 외부 X** | **내부 X / 외부 O** |
| 관리 용이성 | 단순, 교체/스왑 용이 | 의미 반영 좋으나 압축/확장 어려움 |
| 보호/공유 | 페이지 권한·CoW·공유 라이브러리 | 세그먼트 권한 모델(이론적 표현력↑) |
| 성능 포인트 | TLB·다단계 PT·Huge Page | 외부 단편화/압축 비용 이슈 |
| 현대 OS 채택 | **주력(표준)** | 제한적(주로 역사적/특수 용도) |

---

## 8. 하이브리드: 세그먼트+페이지

일부 아키텍처/시대에는 **세그먼트로 큰 논리 영역을 잡고, 내부는 페이지로 관리**(외부 단편화↓, 보호/논리 경계 유지).  
하지만 현재 범용 데스크톱/서버의 메모리 관리 핵심은 **페이징**이며, 세그멘테이션은 대체로 **축소**되었습니다.

> 예) x86-64는 실질적으로 **페이징 중심**이며, 세그먼트는 FS/GS 기반 TLS 등 제한적으로만 사용.

---

## 9. 실무 관점 팁

- **성능**: 메모리 집약 앱(데이터베이스/VM/런타임)은 **Huge Page**·NUMA·TLB 친화적인 메모리 패턴을 고려.
- **안정성**: 잘못된 포인터/버퍼 오버런은 페이지 보호로 **즉시 크래시**되도록(ASLR·NX·W^X).
- **메모리 레이아웃**: 공유 라이브러리/메모리 매핑 파일은 **페이지 단위 공유**로 메모리 절약.
- **GC/VM**: 근래 런타임(JVM/ART 등)도 페이지 단위 보호/매핑을 적극 활용.